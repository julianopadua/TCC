# `sklearn.multiclass` – Visão geral, arquitetura e detalhes de implementação  

> **Objetivo** – Este documento reúne as informações fragmentadas sobre o módulo `sklearn.multiclass`, descrevendo suas estratégias de meta‑estimators, posicionamento na arquitetura do scikit‑learn, API pública, dependências, fluxo interno e pontos de atenção.  

---  

## 1. Visão geral e responsabilidade  

O módulo **`sklearn.multiclass`** fornece estratégias de *meta‑estimators* que transformam um estimador **binário** (classificador ou regressor) em um classificador **multiclasse** ou **multilabel**.  

| Estratégia | Abordagem | Complexidade |
|------------|-----------|--------------|
| **One‑vs‑Rest (OvR)** | Um estimador binário por classe (`n_classes`) | `O(n_classes)` |
| **One‑vs‑One (OvO)** | Um estimador binário por par de classes (`n_classes·(n_classes‑1)/2`) | `O(n_classes²)` |
| **Output‑Code (ECOC)** | Codificação de saída baseada em códigos corretivos; um estimador por bit da codificação | – (implementação em outro arquivo) |

> **Observação:** O código fonte presente neste módulo implementa apenas **OvR** e **OvO**; a classe `OutputCodeClassifier` é exportada, mas sua lógica detalhada está em outro módulo.

---  

## 2. Onde este arquivo se encaixa na arquitetura  

| Camada / Domínio | Função |
|------------------|--------|
| **Camada de Modelos → Estratégias de aprendizado** | Contém meta‑estimators que orquestram outros estimadores para resolver problemas multiclasse/multilabel. |
| **Domínio** | Algoritmos de classificação multiclasse/multilabel. |
| **Interface externa** | Usuário acessa via `sklearn.multiclass.OneVsRestClassifier`, `sklearn.multiclass.OneVsOneClassifier` e `sklearn.multiclass.OutputCodeClassifier`. |

Não há dependência de UI, persistência ou de camada de aplicação; o módulo interage apenas com outras partes da biblioteca scikit‑learn.

---  

## 3. Interfaces e *exports*  

```python
__all__ = [
    "OneVsRestClassifier",
    "OneVsOneClassifier",
    "OutputCodeClassifier",
]
```

| Classe | Papel | Principais métodos públicos | Principais atributos (após `fit`) |
|--------|-------|----------------------------|-----------------------------------|
| **`OneVsRestClassifier`** | Treina um estimador binário por classe (OvR). | `fit`, `partial_fit`, `predict`, `predict_proba`, `decision_function`, `get_metadata_routing`, `__sklearn_tags__` | `estimators_`, `classes_`, `label_binarizer_`, `n_features_in_`, `feature_names_in_` |
| **`OneVsOneClassifier`** | Treina um estimador binário por par de classes (OvO). | `fit`, `partial_fit`, `predict`, `decision_function`, `get_metadata_routing`, `__sklearn_tags__` | `estimators_`, `classes_`, `pairwise_indices_`, `n_features_in_`, `feature_names_in_` |
| **`OutputCodeClassifier`** | Usa códigos corretivos (ECOC) – um estimador por bit da codificação. | `fit`, `predict`, `get_metadata_routing`, `__sklearn_tags__` | `estimators_`, `classes_`, `code_book_`, `n_features_in_`, `feature_names_in_` |

Todas as classes herdam de `BaseEstimator`, `ClassifierMixin` e `MetaEstimatorMixin`, garantindo compatibilidade com a API padrão do scikit‑learn (`fit`, `predict`, …).

---  

## 4. Dependências e acoplamentos  

| Tipo | Módulo / Função | Motivo |
|------|-----------------|--------|
| **Internas** | `sklearn.base` (mixins, `clone`, `is_classifier`) | Estrutura de estimadores e utilitários de clonagem. |
|  | `sklearn.preprocessing.LabelBinarizer` | Binarização de rótulos (OvR). |
|  | `sklearn.utils.validation` (`validate_data`, `check_is_fitted`, `check_classification_targets`) | Validação de entrada e estado. |
|  | `sklearn.utils._param_validation` (`HasMethods`, `Interval`, …) | Validação declarativa de parâmetros. |
|  | `sklearn.utils._tags` | Propagação de *tags* (`pairwise`, `sparse`). |
|  | `sklearn.utils.metadata_routing` (`MetadataRouter`, `MethodMapping`) | Roteamento explícito de parâmetros para sub‑estimadores. |
|  | `sklearn.utils.metaestimators` (`_safe_split`, `available_if`) | Helpers para exposição condicional de métodos. |
|  | `sklearn.utils.multiclass` (`_ovr_decision_function`, `check_classification_targets`) | Funções auxiliares de decisão e verificação. |
|  | `sklearn.utils.parallel` (`Parallel`, `delayed`) | Paralelização de treinamento de múltiplos estimadores. |
|  | `sklearn.metrics.pairwise` (`pairwise_distances_argmin`) | Busca da classe mais próxima no ECOC. |
|  | `sklearn.utils._estimator_html_repr` (`_estimators_has`, `_available_if`, …) | Exposição dinâmica de atributos/métodos. |
| **Externas** | `numpy` (`np`) | Operações numéricas e manipulação de arrays. |
|  | `scipy.sparse` (`sp`) | Representação esparsa de indicadores multilabel. |
|  | `itertools`, `warnings`, `numbers`, `array` | Utilitários padrão da linguagem. |
|  | `joblib` (`Parallel`, `delayed`) | Implementação de paralelismo (também listada acima). |

O módulo **não** depende de código de aplicação externo; seu acoplamento está restrito a outras partes da própria biblioteca scikit‑learn.

---  

## 5. Leitura guiada do código (top‑down)  

### 5.1 Docstring e imports  
* A docstring descreve as estratégias suportadas e o comportamento de `predict_proba` em cenários multilabel.  
* Os imports trazem os utilitários listados na seção 4.

### 5.2 Funções auxiliares (internas)  

| Função | Responsabilidade |
|--------|------------------|
| `_fit_binary`, `_partial_fit_binary` | Treinam ou atualizam **um** estimador binário a partir de `X` e de um vetor de rótulos binários. |
| `_predict_binary` | Obtém a predição (ou decisão) de um estimador binário. |
| `_threshold_for_binary_predict` | Aplica limiar (default = 0.5) para converter probabilidades em indicadores binários (usado em multilabel). |
| `_ConstantPredictor` | Estimador “dummy” que devolve sempre a mesma classe quando o conjunto de treinamento contém apenas um rótulo. |
| `_estimators_has` | Helper usado por `available_if` para expor dinamicamente métodos apenas se o estimador interno os possuir. |
| `_fit_ovo_binary`, `_partial_fit_ovo_binary` | Preparam subconjuntos de dados para cada **par** de classes e delegam ao `_fit_binary`/`_partial_fit_binary`. |
| `_ovr_decision_function` | Agrega as decisões de todos os classificadores OvR para produzir a decisão final. |
| `_raise_for_params`, `_check_partial_fit_first_call`, `_check_method_params` | Valida parâmetros e estado nas rotinas de `fit`/`partial_fit`. |

### 5.3 Classe **`OneVsRestClassifier`** (OvR)  

| Etapa | Descrição |
|------|-----------|
| **`__init__`** | Armazena `estimator`, `n_jobs` e `verbose`. |
| **`fit`** | <ul><li>Valida `X`, `y` e converte `y` em matriz esparsa binária usando `LabelBinarizer(sparse_output=True)`.</li><li>Treina, em paralelo, um estimador binário por classe via `Parallel(..., delayed(_fit_binary))`.</li><li>Propaga atributos como `n_features_in_` e `feature_names_in_` do primeiro estimador.</li></ul> |
| **`partial_fit`** | Disponível somente se o estimador base implementa `partial_fit`. Gerencia a primeira chamada (cria clones) e, nas subsequentes, atualiza cada estimador usando `_partial_fit_binary`. |
| **`predict`** | <ul><li>**Multiclass** – escolhe a classe com maior escore (`_predict_binary`).</li><li>**Multilabel** – aplica limiar (`_threshold_for_binary_predict`) e devolve matriz esparsa de indicadores.</li></ul> |
| **`predict_proba`** | Exposto via `available_if`; concatena as probabilidades de cada estimador (`e.predict_proba(X)[:,1]`). Normaliza quando o problema **não** é multilabel. |
| **`decision_function`** | Também exposto via `available_if`; concatena as funções de decisão de cada estimador. |
| **Propriedades** | `multilabel_` (bool) e `n_classes_` (int) facilitam introspecção. |
| **`__sklearn_tags__`** | Propaga *tags* de entrada (`pairwise`, `sparse`) do estimador interno. |
| **`get_metadata_routing`** | Define como os parâmetros de `fit`/`partial_fit` são encaminhados ao estimador interno. |

### 5.4 Classe **`OneVsOneClassifier`** (OvO)  

| Etapa | Descrição |
|------|-----------|
| **`__init__`** | Armazena `estimator`, `n_jobs` e `verbose`. |
| **`fit`** | <ul><li>Valida dados e verifica a existência de pelo menos duas classes.</li><li>Gera todos os pares `(i, j)` de classes.</li><li>Para cada par, chama `_fit_ovo_binary` em paralelo, treinando um estimador binário que vê apenas as amostras das duas classes.</li><li>Armazena a lista `estimators_` e, quando o estimador aceita Gram (`pairwise`), guarda `pairwise_indices_`.</li></ul> |
| **`partial_fit`** | Semelhante ao de OvR, mas usa `_partial_fit_ovo_binary` para atualizar os estimadores por par. |
| **`predict`** | Usa `decision_function` para obter votos de cada estimador e decide por maioria. |
| **`decision_function`** | Concatena as decisões de todos os pares e aplica `_ovr_decision_function` para obter a votação final. |
| **`__sklearn_tags__`** | Propaga as *tags* do estimador base (incluindo `pairwise`). |
| **`get_metadata_routing`** | Roteia parâmetros de `fit`/`partial_fit` para os sub‑estimadores. |

### 5.5 Classe **`OutputCodeClassifier`** (ECOC)  

| Etapa | Descrição |
|------|-----------|
| **`__init__`** | Recebe `estimator`, `code_size`, `random_state` e `n_jobs`. |
| **`fit`** | <ul><li>Valida `X`, `y` e extrai as classes.</li><li>Gera um *code book* aleatório de tamanho `n_classes × n_estimators` (onde `n_estimators = int(n_classes * code_size)`).</li><li>Converte o código para `{-1, 1}` se o estimador tem `decision_function`, caso contrário para `{0, 1}`.</li><li>Cria a matriz binária `Y` a partir do *code book* e treina, em paralelo, um estimador binário por coluna usando `_fit_binary`.</li></ul> |
| **`predict`** | <ul><li>Obtém probabilidades ou decisões binárias de cada estimador (`_predict_binary`).</li><li>Forma a matriz de códigos preditos e escolhe a classe cujo código tem menor distância euclidiana (`pairwise_distances_argmin`).</li></ul> |
| **`__sklearn_tags__`** | Propaga a *tag* `sparse` do estimador interno. |
| **`get_metadata_routing`** | Encaminha apenas os parâmetros de `fit` para o estimador interno. |

---  

## 6. Fluxo de dados / estado  

### 6.1 One‑vs‑Rest (OvR)

```mermaid
flowchart TD
    A[Entrada X, y] -->|fit| B[LabelBinarizer → Y (esparso)]
    B --> C{n_classes}
    C -->|para cada classe| D[_fit_binary(estimator, X, y_i)]
    D --> E[estimador_i treinado]
    E -->|armazenado| F[estimators_ list]
    F --> G[atributos n_features_in_, feature_names_in_]
    G --> H[Objeto OneVsRestClassifier ajustado]

    subgraph Predição
        I[Entrada X] --> J[predict]
        J --> K{multiclass?}
        K -->|sim| L[_predict_binary(e_i, X) → scores]
        L --> M[argmax(scores) → classe]
        K -->|não| N[_predict_binary(e_i, X) > thresh → indicadores]
        N --> O[inverse_transform → rótulos multilabel]
    end
```

- **Estado interno** após `fit`: `estimators_`, `label_binarizer_`, `classes_`, `n_features_in_`, `feature_names_in_`.  
- `partial_fit` reutiliza a mesma lista de estimadores, atualizando‑os em vez de recriá‑los.

### 6.2 One‑vs‑One (OvO)

```mermaid
flowchart TD
    A[Entrada X, y] -->|fit| B[Extrai classes → C]
    B --> D{pares (i,j)}
    D -->|para cada par| E[_fit_ovo_binary(estimator, X_pair, y_pair)]
    E --> F[estimador_ij treinado]
    F --> G[estimators_ list + pairwise_indices_ (se aplicável)]
    G --> H[Objeto OneVsOneClassifier ajustado]

    subgraph Predição
        I[Entrada X] --> J[decision_function]
        J --> K[agrega votos → majority vote]
        K --> L[predict → classe]
    end
```

- **Estado interno**: `estimators_`, `pairwise_indices_` (quando o estimador aceita Gram), `classes_`, `n_features_in_`, `feature_names_in_`.

### 6.3 Output‑Code (ECOC)

```mermaid
flowchart TD
    A[Entrada X, y] -->|fit| B[code_book_ (n_classes × n_estimators)]
    B --> C[Transforma y → Y (binário)]
    C --> D{para cada bit} 
    D --> E[_fit_binary(estimator, X, Y_bit)]
    E --> F[estimador_bit treinado]
    F --> G[estimators_ list]
    G --> H[Objeto OutputCodeClassifier ajustado]

    subgraph Predição
        I[Entrada X] --> J[predict (prob/dec)]
        J --> K[matriz códigos preditos]
        K --> L[distância mínima ao code_book_ → classe]
    end
```

- **Estado interno**: `estimators_`, `code_book_`, `classes_`, `n_features_in_`, `feature_names_in_`.

---  

## 7. Conexões com outros arquivos do projeto  

| Módulo / Função | Onde é usado | Tipo de vínculo |
|-----------------|--------------|-----------------|
| `sklearn.base` (`BaseEstimator`, `ClassifierMixin`, `MetaEstimatorMixin`) | Classes públicas | Herança e mixins. |
| `sklearn.preprocessing.LabelBinarizer` | `OneVsRestClassifier.fit` | Binarização de rótulos. |
| `sklearn.utils.validation` (`validate_data`, `check_is_fitted`, `check_classification_targets`) | Em todos os `fit`/`partial_fit`/`predict` | Validação de entrada e estado. |
| `sklearn.utils._param_validation` (`HasMethods`, `Interval`, …) | Decoradores de validação de parâmetros | Declaração de restrições. |
| `sklearn.utils._tags` | `__sklearn_tags__` de cada classe | Propagação de *tags* (`pairwise`, `sparse`). |
| `sklearn.utils.metadata_routing` (`MetadataRouter`, `MethodMapping`) | `get_metadata_routing` | Roteamento explícito de parâmetros para sub‑estimadores. |
| `sklearn.utils.parallel` (`Parallel`, `delayed`) | Treinamento paralelo em OvR, OvO e ECOC | Paralelismo. |
| `sklearn.utils.multiclass` (`_ovr_decision_function`, `check_classification_targets`) | Decisão final em OvR/OvO | Funções auxiliares. |
| `sklearn.metrics.pairwise` (`pairwise_distances_argmin`) | `OutputCodeClassifier.predict` | Busca da classe mais próxima no *code book*. |
| `sklearn.utils._estimator_html_repr` (`_estimators_has`, `_available_if`, …) | Exposição condicional de atributos/métodos | Metadados para documentação e UI. |
| `numpy`, `scipy.sparse`, `itertools`, `warnings`, `numbers`, `array` | Diversas rotinas auxiliares | Utilitários padrão. |
| `joblib` (`Parallel`, `delayed`) | Paralelismo (também listado em `sklearn.utils.parallel`) | Execução paralela. |

---  

## 8. Pontos de atenção, riscos e recomendações  

| Item | Descrição | Recomendações |
|------|-----------|---------------|
| **Tratamento de classe única** | Quando o conjunto de treinamento contém apenas um rótulo, `_ConstantPredictor` gera previsões constantes. Pode confundir métricas que esperam variação. | Documentar explicitamente esse comportamento nas métricas; emitir `UserWarning` em vez de `warnings.warn` genérico. |
| **Escalabilidade OVO** | Complexidade `O(n_classes²)` → milhares de estimadores para muitos rótulos. | Sugerir `OneVsRestClassifier` ou `OutputCodeClassifier` para `n_classes` > ~50; incluir aviso de desempenho no docstring. |
| **Paralelismo** | `Parallel` introduz overhead para estimadores muito rápidos; o código já contém comentário a respeito. | Expor parâmetro `prefer` (threads vs processes) ou heurística automática baseada em `n_samples`. |
| **Suporte a `partial_fit`** | Disponível apenas se o estimador base implementa `partial_fit`. Não há verificação de consistência de `classes_` entre chamadas. | Adicionar validação explícita de `classes_` invariantes; documentar limitações. |
| **Normalização de probabilidades (OvR)** | Em `predict_proba` a normalização ocorre apenas quando `multilabel_` é `False`. Se a soma for quase zero, pode gerar `nan`. | Inserir safeguard (`np.clip` ou `np.where`) antes da normalização. |
| **Código aleatório no ECOC** | O *code book* é gerado aleatoriamente; a qualidade da codificação pode variar. | Oferecer opções de geração estruturada (e.g., códigos de Hadamard) ou controle de distância mínima entre códigos. |
| **Roteamento de metadados** | Implementado a partir da versão 1.4; versões anteriores podem lançar `AttributeError`. | Incluir fallback ou aviso de depreciação para usuários de versões antigas. |
| **Uso de `pairwise`** | Quando o estimador aceita matrizes de Gram, `pairwise_indices_` armazena índices de amostras. Mistura de estimadores que aceitam e que não aceitam pode gerar erros. | Validar coerência entre `pairwise` e `n_jobs`; lançar erro claro se houver incompatibilidade. |
| **Cobertura de testes** | Funções auxiliares (`_fit_binary`, `_fit_ovo_binary`, etc.) são internas, mas críticas. | Garantir testes unitários que cubram caminhos de exceção (classe única, ausência de `decision_function`, `partial_fit`). |
| **Memória em `partial_fit` (OvO)** | Cria clones de **todos** os sub‑estimadores na primeira chamada, consumindo memória proporcional a `n_classes²`. | Avaliar estratégia de *lazy* instantiation ou descarregamento entre batches. |
| **Documentação de limites de memória** | Uso de `LabelBinarizer(sparse_output=True)` reduz memória, mas a conversão `Y.tocsc()` ainda pode ser custosa para datasets muito grandes. | Documentar limites recomendados de `n_samples`/`n_classes` e sugerir uso de `partial_fit` ou algoritmos incrementais quando apropriado. |

---  

### Conclusão  

O módulo `sklearn.multiclass` fornece três estratégias de meta‑estimators (OvR, OvO e ECOC) que permitem transformar qualquer estimador binário em um classificador multiclasse/multilabel. A implementação segue rigorosamente a API do scikit‑learn, utiliza paralelismo via `joblib`, roteamento de metadados e propagação de *tags* para garantir compatibilidade e desempenho.  

Os pontos de atenção listados acima devem ser monitorados nas próximas versões para melhorar robustez, usabilidade e eficiência em cenários de grande escala.
